<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esquema Ã“ptico con Imagen Real/Virtual</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1;
            user-select: none;
        }
        #info h3 { margin-top: 0; color: #1f2937; }
        #info p { margin-bottom: 5px; font-size: 14px; }
        #status {
            position: absolute;
            bottom: 10px; left: 10px;
            background: rgba(17, 24, 39, 0.9);
            color: #d1d5db; 
            padding: 10px;
            border-radius: 8px;
            font-size: 14px; 
            font-family: monospace;
            z-index: 1;
            user-select: none;
            line-height: 1.5;
        }
        #status b { color: #facc15; }
        .label {
            position: absolute;
            background: rgba(255,255,255,0.95);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            pointer-events: none;
            user-select: none;
            border: 1px solid #9ca3af;
            white-space: nowrap;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Esquema Ã“ptico (Espejo CÃ³ncavo)</h3>
    <p>Arrastra el objeto para ver los cambios.</p>
    <p>ðŸŸ£ Objeto (Real)</p>
    <p>ðŸŸ¡ Imagen (Real/Virtual)</p>
    <p style="color: #0000ff;">â€” Rayo Central (a travÃ©s de C)</p>
    <p style="color: #ff0000;">â€” Rayo Paralelo</p>
</div>
<div id="status"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/DragControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/objects/Reflector.js"></script>

<script>
(() => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(10, 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = false;

    // --- Variables Ã“pticas Clave ---
    const vertexZ Â  = -4; Â  Â  Â  Â  // PosiciÃ³n Z del VÃ©rtice (Espejo)
    const f Â  Â  Â  Â  = 1.0; Â  Â  Â // Distancia Focal (f = R/2)
    const objHeight = 0.65; Â  Â  // Altura base del objeto (usada para la escala)
    const objBaseY Â = 1.5; Â  Â  Â // Eje Ã³ptico Y
    const minObjectZ = -15; Â  Â  // LÃ­mite trasero (lejos de la cÃ¡mara)
    const maxObjectZ = 5; Â  Â  Â  // LÃ­mite frontal (cerca de la cÃ¡mara)

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Suelo
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20),
        new THREE.MeshPhongMaterial({ color: 0xdddddd, side: THREE.DoubleSide }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Sujeto (ojo - no funcional en Ã³ptica, solo decorativo)
    const ojo = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshPhongMaterial({ color: 0xff0000, opacity: 0.5, transparent: true }));
    ojo.position.set(0, objBaseY, 6);
    scene.add(ojo);

    // --- Espejo Plano (Reflector) ---
    const mirrorGeometry = new THREE.PlaneGeometry(4, 4);
    const mirrorFront = new THREE.Mesh(mirrorGeometry, 
        new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide }));
    mirrorFront.position.set(0, objBaseY, 0.02); 
    scene.add(mirrorFront);
    const mirrorPlane = new THREE.Reflector(mirrorGeometry, {
        clipBias: 0.001,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        color: 0xcccccc 
    });
    mirrorPlane.rotation.y = Math.PI;
    mirrorPlane.position.set(0, objBaseY, 0); 
    scene.add(mirrorPlane);
    
    // Espejo CÃ³ncavo (Lente/Espejo principal)
    const concaveMirror = new THREE.Mesh(new THREE.SphereGeometry(2 * f, 32, 32, 0, Math.PI),
        new THREE.MeshPhongMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true, side: THREE.BackSide }));
    concaveMirror.rotation.y = Math.PI;
    concaveMirror.position.set(0, objBaseY, vertexZ - (2 * f)); // Posiciona el centro en Z = -6
    scene.add(concaveMirror);

    // Marcadores y Etiquetas
    const vertexMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    vertexMarker.position.set(0, objBaseY, vertexZ);
    scene.add(vertexMarker);

    const focoMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    focoMarker.position.set(0, objBaseY, vertexZ + f);
    scene.add(focoMarker);

    const vertexLabel = document.createElement('div');
    vertexLabel.className = 'label';
    vertexLabel.innerText = 'V (VÃ©rtice)';
    document.body.appendChild(vertexLabel);

    const focoLabel = document.createElement('div');
    focoLabel.className = 'label';
    focoLabel.innerText = 'F (Foco)';
    document.body.appendChild(focoLabel);

    // --- Objeto Real (Grupo) ---
    const objetoReal = new THREE.Group();

    // Mesa (Base del objeto)
    const mesa = new THREE.Group();
    const pared = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.6), new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    pared.position.set(0, 0.3, 0.2); pared.rotation.y = Math.PI / 2; mesa.add(pared);
    const baseInferior = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 0.4), new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    baseInferior.position.set(0, 0.025, 0); mesa.add(baseInferior);
    const baseSuperior = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 0.4), new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    baseSuperior.position.set(0, 0.575, 0); mesa.add(baseSuperior);
    objetoReal.add(mesa);

    // JarrÃ³n y flores (Lo que se magnifica)
    const vaso = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.15, 0.5, 32),
        new THREE.MeshPhongMaterial({ color: 0x4f46e5 }));
    vaso.position.set(0, 0.3, -0.1); 
    vaso.rotation.x = Math.PI;
    vaso.scale.set(0.9, 0.9, 0.9);
    objetoReal.add(vaso);

    for (let i = 0; i < 3; i++) {
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8),
            new THREE.MeshPhongMaterial({ color: 0x228B22 }));
        stem.position.set((i - 1) * 0.08, 0.5 + 0.575 + 0.3, 0); 
        objetoReal.add(stem);

        const flower = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16),
            new THREE.MeshPhongMaterial({ color: [0xff69b4, 0xffff00, 0xff0000][i % 3] }));
        flower.position.set(stem.position.x, 0.5 + 0.575 + 0.6 + 0.07, 0); 
        objetoReal.add(flower);
    }
    
    // PosiciÃ³n inicial del objeto
    objetoReal.position.set(0, objBaseY - (0.575 + 0.05 / 2), -2); 
    scene.add(objetoReal);

    // Crear un grupo para la imagen (solo jarrÃ³n y flores)
    const imagenGrupo = new THREE.Group();
    objetoReal.children.forEach(child => {
        if (child.isGroup && child === mesa) return; 
        imagenGrupo.add(child.clone());
    });
    imagenGrupo.traverse(node => {
        if (node.isMesh) node.material = node.material.clone();
        if (node.material) node.material.color.set(0xa855f7); // Violeta
        if (node.material) node.material.opacity = 0.6;
        if (node.material) node.material.transparent = true;
    });
    scene.add(imagenGrupo);
    imagenGrupo.position.copy(objetoReal.position);

    // Control invisible para arrastrar el objeto real
    const dragControlObject = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1), 
        new THREE.MeshBasicMaterial({ visible: false })
    );
    dragControlObject.position.copy(objetoReal.position);
    scene.add(dragControlObject);

    const dragControls = new THREE.DragControls([dragControlObject], camera, renderer.domElement);
    dragControls.addEventListener('dragstart', e => controls.enabled = false);
    dragControls.addEventListener('dragend', e => controls.enabled = true);
    
    // --- LÃ“GICA DE DRAG CONTROLS CORREGIDA ---
    // --- LÃ“GICA DE DRAG CONTROLS CORREGIDA ---
dragControls.addEventListener('drag', e => {
    const dragControlObject = e.object;

    // --- LÃMITES DE MOVIMIENTO ---
    // 1. RestricciÃ³n X: Solo movimiento en Y y Z
    dragControlObject.position.x = 0; 
    
    // 2. RestricciÃ³n Z: El objeto debe estar EN la cara reflectante (a la derecha) o fuera de la simulaciÃ³n
    // El objeto estÃ¡ en Z=-2, el espejo en Z=-4.
    // Queremos que el objeto se mueva hacia la izquierda (mÃ¡s negativo) hasta el lÃ­mite trasero (-15)
    // Y no puede cruzar el espejo (debe ser Z >= vertexZ + 0.01)

    const minAllowedZ = vertexZ + 0.01; // No puede cruzar el espejo (Z=-4) hacia la izquierda
    const maxAllowedZ = 5; 

    // El objeto real copia la posiciÃ³n del objeto arrastrable
    objetoReal.position.copy(dragControlObject.position);

    // --- Aplicar el lÃ­mite de Z ---
    if (objetoReal.position.z < minAllowedZ) {
        objetoReal.position.z = minAllowedZ;
        dragControlObject.position.z = minAllowedZ;
    }
    if (objetoReal.position.z > maxAllowedZ) {
        objetoReal.position.z = maxAllowedZ;
        dragControlObject.position.z = maxAllowedZ;
    }
    if (objetoReal.position.z < minObjectZ) {
        objetoReal.position.z = minObjectZ;
        dragControlObject.position.z = minObjectZ;
    }

    // --- CÃLCULOS Ã“PTICOS ---
    const doZ = objetoReal.position.z;
    const doDist = doZ - vertexZ; // Distancia Objeto (dâ‚€)
    if (Math.abs(doDist) < 0.001) return; // evitar divisiÃ³n por cero

    // EcuaciÃ³n del espejo
    const invDi = 1 / f - 1 / doDist;
    const di = 1 / invDi;

    // MagnificaciÃ³n (M = -di / do)
    const magnification = -di / doDist;

    // --- CALCULAR hâ‚€ (altura del objeto desde el eje Ã³ptico) ---
    const objCenterY = objetoReal.position.y;
    const objTipY = objCenterY + objHeight / 2; 
    const ho = objTipY - objBaseY; 

    // --- CALCULAR háµ¢ CON SIGNO: Altura de la imagen (háµ¢ = M * hâ‚€) ---
    const hi = magnification * ho; 

    // --- POSICIÃ“N, ESCALA Y ROTACIÃ“N DE LA IMAGEN ---
    // 1. PosiciÃ³n Z (distancia imagen)
    imagenGrupo.position.z = vertexZ + di;

    // 2. PosiciÃ³n Y (base fija + mitad de altura de la imagen)
    const imagenBaseY = objBaseY;
    imagenGrupo.position.y = imagenBaseY + (hi / 2);

    // 3. RotaciÃ³n (inversiÃ³n si es imagen real)
    imagenGrupo.rotation.x = magnification < 0 ? Math.PI : 0; 

    // 4. Escala uniforme (solo agranda o achica)
    const scaleFactor = Math.abs(magnification);
    imagenGrupo.scale.setScalar(scaleFactor);

    // --- Actualizar rayos ---
    drawRays(); 
});



    // --- RAYOS VISUALES: CONFIGURACIÃ“N INICIAL ---
    
    // Ray 1: Rayo Paralelo
    const rayParallelIncident = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xff0000 }));
    const rayParallelReflected = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xff0000 }));

    // Ray 2: Rayo Central (a travÃ©s de C)
    const rayCentralIncident = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x0000ff }));
    const rayCentralReflected = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x0000ff }));
    
    // El rayo guÃ­a de la imagen
    const matImagen = new THREE.LineDashedMaterial({ color: 0xa855f7, dashSize: 0.1, gapSize: 0.05 });
    let rayImagen = new THREE.Line(new THREE.BufferGeometry(), matImagen);
    rayImagen.name = "rayImagen";
    scene.add(rayImagen);
    
    scene.add(rayParallelIncident, rayParallelReflected, rayCentralIncident, rayCentralReflected);
    

    // --- FUNCIONES AUXILIARES ---

    function updateLabelPosition(label, position) {
        const vector = position.clone();
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        label.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
    }

    const statusEl = document.getElementById('status');

    function formatNumber(value) {
        if (!isFinite(value) || value === null || isNaN(value)) {
            return 'Â±âˆž';
        }
        return value.toFixed(2);
    }

    function updateStatus(hi, doDist, di, magnification) {

        const tipo = di > 0 ? 'Real (invertida)' : 'Virtual (derecha)';

        statusEl.innerHTML = `
            Distancia Objeto (dâ‚€): ${doDist.toFixed(2)} u<br>
            Distancia Imagen (dáµ¢): ${formatNumber(di)} u<br>
            MagnificaciÃ³n (M): ${formatNumber(magnification)}<br>
            Altura Imagen (háµ¢): ${formatNumber(hi)} u<br>
            Tipo: <b>${tipo}</b>
        `;
    }


    function drawRays() {
        // --- 1. CÃ¡lculos Ã“pticos ---
        const objCenterY = objetoReal.position.y;
        const objTipY = objCenterY + objHeight / 2; // La punta del objeto
        const doZ = objetoReal.position.z;
        const doDist = doZ - vertexZ; 
        
        const invDi = 1 / f - 1 / doDist;
        const di = invDi === 0 ? (invDi > 0 ? 1e6 : -1e6) : 1 / invDi;
        
        const real = di > 0; 
        const imagenZ = vertexZ + di;

        const magnification = doDist === 0 ? 0 : -di / doDist;
        
        const ho = objTipY - objBaseY;
        const hi = magnification * ho; 
        
        // PosiciÃ³n final de la punta de la imagen (calculada de forma robusta)
        const reflTarget = new THREE.Vector3(0, objBaseY + hi, imagenZ);
        
        // --- 2. Materiales Punteados/SÃ³lidos (Virtual vs. Real) ---

        const setDashed = (line, color) => {
            if (!(line.material && line.material.isLineDashedMaterial)) {
                line.material = new THREE.LineDashedMaterial({ color: color, dashSize: 0.1, gapSize: 0.05 });
                line.computeLineDistances();
            }
        };

        const setSolid = (line, color) => {
            if (line.material && line.material.isLineDashedMaterial) {
                line.material = new THREE.LineBasicMaterial({ color: color });
            }
        };

        // --- 3. Rayo 1: Paralelo (Incidente) -> Foco (Reflejado) ---
        
        const origin1 = new THREE.Vector3(0, objTipY, doZ);
        const hit1 = new THREE.Vector3(0, objTipY, vertexZ); 
        
        // Rayo Incidente (SÃ³lido)
        rayParallelIncident.geometry.setFromPoints([origin1, hit1]);
        setSolid(rayParallelIncident, 0xff0000);
        
        // Rayo Reflejado (Debe ir de hit1 hacia el foco y extenderse hasta reflTarget)
        if (real) {
            // Real: SÃ³lido H1 -> ReflTarget
            rayParallelReflected.geometry.setFromPoints([hit1, reflTarget]);
            setSolid(rayParallelReflected, 0xff0000);
        } else {
            // Virtual: SÃ³lido H1 -> LÃ­mite frontal (e.g., ojo.position.z)
            rayParallelReflected.geometry.setFromPoints([hit1, ojo.position]);
            setSolid(rayParallelReflected, 0xff0000);

            // ProlongaciÃ³n punteada: ReflTarget -> H1
            rayParallelReflected.geometry.setFromPoints([reflTarget, hit1]);
            setDashed(rayParallelReflected, 0xff0000);
        }
        
        // --- 4. Rayo 2: Central (Incidente O -> C) -> Reflejado (C -> I) ---
        
        const centroPos = new THREE.Vector3(0, objBaseY, vertexZ + 2 * f);
        const origin2 = new THREE.Vector3(0, objTipY, doZ);
        
        // Encontrar la intersecciÃ³n del rayo O->C con el plano del espejo (Z = vertexZ)
        const dirToCentro = centroPos.clone().sub(origin2);
        let t_centro = 0;
        if (Math.abs(dirToCentro.z) > 1e-6) {
            t_centro = (vertexZ - origin2.z) / dirToCentro.z;
        } else {
            t_centro = 1; 
        }
        
        const hit2 = origin2.clone().add(dirToCentro.clone().multiplyScalar(t_centro));
        
        // Rayo Incidente: SÃ³lido O -> H2
        rayCentralIncident.geometry.setFromPoints([origin2, hit2]);
        setSolid(rayCentralIncident, 0x0000ff);
        
        // Rayo Reflejado: H2 -> I. Para rayo central, la reflexiÃ³n sigue el camino inverso.
        if (real) {
            // Real: SÃ³lido H2 -> ReflTarget
            rayCentralReflected.geometry.setFromPoints([hit2, reflTarget]);
            setSolid(rayCentralReflected, 0x0000ff);
        } else {
            // Virtual: SÃ³lido H2 -> LÃ­mite frontal
            rayCentralReflected.geometry.setFromPoints([hit2, ojo.position]);
            setSolid(rayCentralReflected, 0x0000ff);

            // ProlongaciÃ³n punteada: ReflTarget -> H2
            rayCentralReflected.geometry.setFromPoints([reflTarget, hit2]);
            setDashed(rayCentralReflected, 0x0000ff);
        }

        // --- 5. LÃ­nea guÃ­a punteada Imagen -> Eje Ã“ptico ---
        const pImagen = reflTarget.clone();
        const eje = new THREE.Vector3(0, objBaseY, pImagen.z);
        
        rayImagen.geometry.setFromPoints([pImagen, eje]);
        if (rayImagen.material && rayImagen.material.isLineDashedMaterial) rayImagen.computeLineDistances();
        
        // --- 6. Actualizar el estado ---
        updateStatus(hi, doDist, di, magnification);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        updateLabelPosition(vertexLabel, vertexMarker.position);
        updateLabelPosition(focoLabel, focoMarker.position);

        drawRays(); 

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
})();
</script>
</body>
</html>
