<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <title>Esquema Óptico con Imagen Real/Virtual</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            font-family: Arial;
            z-index: 1;
            user-select: none;
        }
        #status {
            position: absolute;
            bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.6);
            color: #fff; padding: 8px;
            font-size: 14px; font-family: monospace;
            z-index: 1;
            user-select: none;
        }
        .label {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            pointer-events: none;
            user-select: none;
            border: 1px solid #aaa;
            white-space: nowrap;
            z-index: 2;
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Esquema Óptico</h3>
    <p>
        🔴 Sujeto (ojo) <br>
        🔵 Espejo plano <br>
        🔵 Transparente: Espejo cóncavo <br>
        🟣 Imagen (real/virtual) <br>
        🟡 Líneas amarillas: rayos visuales
    </p>
</div>
<div id="status"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
<!-- Se ha corregido la URL de DragControls.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/DragControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/objects/Reflector.js"></script>

<script>
(() => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Suelo
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20),
        new THREE.MeshPhongMaterial({ color: 0xdddddd, side: THREE.DoubleSide }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Sujeto (ojo)
    const ojo = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshPhongMaterial({ color: 0xff0000, opacity: 0.5, transparent: true }));
    ojo.position.set(0, 1.5, 6);
    scene.add(ojo);

    // --- Espejo Plano con dos caras ---
    const mirrorGeometry = new THREE.PlaneGeometry(3, 3);
    
    // Cara frontal opaca (la que mira al sujeto)
    const mirrorFront = new THREE.Mesh(mirrorGeometry, 
        new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide }));
    mirrorFront.position.set(0, 1.5, 0.02); 
    scene.add(mirrorFront);

    // Cara posterior reflectante (la que mira al objeto)
    const mirrorPlane = new THREE.Reflector(mirrorGeometry, {
        clipBias: 0.003,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        color: 0xcccccc // Color base del reflejo
    });
    // Rotamos la malla reflectante para que su cara frontal mire hacia los objetos.
    mirrorPlane.rotation.y = Math.PI;
    mirrorPlane.position.set(0, 1.5, 0); 
    scene.add(mirrorPlane);
    
    // Espejo Cóncavo
    const concaveMirror = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32, 0, Math.PI),
        new THREE.MeshPhongMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true, side: THREE.BackSide }));
    concaveMirror.rotation.y = Math.PI;
    concaveMirror.position.set(0, 1.5, -4);
    scene.add(concaveMirror);

    // Vértice y Foco del espejo cóncavo
    const vertexZ = -4;
    const f = 1;
    const vertexMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    vertexMarker.position.set(0, 1.5, vertexZ);
    scene.add(vertexMarker);

    const focoMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    focoMarker.position.set(0, 1.5, vertexZ + f);
    scene.add(focoMarker);

    // Etiquetas HTML para el vértice y el foco
    const vertexLabel = document.createElement('div');
    vertexLabel.className = 'label';
    vertexLabel.innerText = 'Vértice';
    document.body.appendChild(vertexLabel);

    const focoLabel = document.createElement('div');
    focoLabel.className = 'label';
    focoLabel.innerText = 'Foco';
    document.body.appendChild(focoLabel);

    // Grupo de objeto real: mesa + jarrón + flores
    const objetoReal = new THREE.Group();

    // Mesa
    const mesa = new THREE.Group();
    const pared = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.4),
        new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    pared.position.set(0, 0.3, 0.2);
    pared.rotation.y = Math.PI / 2;
    mesa.add(pared);
    const baseInferior = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.4),
        new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    baseInferior.position.set(0, 0.025, 0);
    mesa.add(baseInferior);
    const baseSuperior = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.4),
        new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    baseSuperior.position.set(0, 0.575, 0);
    mesa.add(baseSuperior);

    objetoReal.add(mesa);

    // Jarrón y flores
    const vaso = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.15, 0.5, 32),
        new THREE.MeshPhongMaterial({ color: 0x2222aa }));
    vaso.position.set(0, 0.25, 0);
    vaso.rotation.x = Math.PI
    objetoReal.add(vaso);

    for (let i = 0; i < 3; i++) {
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8),
            new THREE.MeshPhongMaterial({ color: 0x228B22 }));
        stem.position.set((i - 1) * 0.08, 0.9, 0);
        objetoReal.add(stem);

        const flower = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16),
            new THREE.MeshPhongMaterial({ color: [0xff69b4, 0xffff00, 0xff0000][i % 3] }));
        flower.position.set(stem.position.x, 1.2, 0);
        objetoReal.add(flower);
    }
    
    // El objeto real no está invertido
    objetoReal.position.set(0, 0, -2);
    scene.add(objetoReal);

    // Crear un grupo temporal con todo menos la mesa
    const objetoSinMesa = new THREE.Group();
    objetoReal.children.forEach(child => {
        if (child !== mesa) {
            objetoSinMesa.add(child.clone());
        }
    });

    // Clonar solo el grupo sin la mesa para imagenGrupo
    const imagenGrupo = objetoSinMesa.clone();
    imagenGrupo.traverse(node => {
        if (node.isMesh) node.material = node.material.clone();
        if (node.material) node.material.color.set(0x9933ff);
        if (node.material) node.material.opacity = 0.4;
        if (node.material) node.material.transparent = true;
    });
    scene.add(imagenGrupo);


    // Control invisible para arrastrar el objeto real
    const dragControlObject = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    dragControlObject.position.copy(objetoReal.position);
    scene.add(dragControlObject);

    const dragControls = new THREE.DragControls([dragControlObject], camera, renderer.domElement);
    dragControls.addEventListener('dragstart', e => controls.enabled = false);
    dragControls.addEventListener('dragend', e => controls.enabled = true);
    dragControls.addEventListener('drag', e => {
        objetoReal.position.copy(dragControlObject.position);

        const doZ = objetoReal.position.z;
        const doDist = Math.abs(doZ - vertexZ);
        const invDi = 1 / f - 1 / doDist;
        const di = invDi === 0 ? 999 : 1 / invDi;
        const real = di > 0;

        imagenGrupo.position.set(objetoReal.position.x, objetoReal.position.y, vertexZ + di);

        const magnification = -di / doDist;
        imagenGrupo.scale.set(Math.abs(magnification), Math.abs(magnification), 1);
        
        imagenGrupo.rotation.x = real ? Math.PI : 0; 
        
        const alturaObjetoVisible = 0.65; 
        if (real) {
            imagenGrupo.position.y = objetoReal.position.y + (alturaObjetoVisible * Math.abs(magnification));
        } else {
            imagenGrupo.position.y = objetoReal.position.y;
        }
    });

    // Rayos visuales: ojo->objeto, objeto->vértice, objeto->foco
    const rayMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
    const rayOjoObjeto = new THREE.Line(new THREE.BufferGeometry(), rayMaterial);
    const rayObjetoVertice = new THREE.Line(new THREE.BufferGeometry(), rayMaterial);
    const rayObjetoFoco = new THREE.Line(new THREE.BufferGeometry(), rayMaterial);
    scene.add(rayOjoObjeto, rayObjetoVertice, rayObjetoFoco);

    function updateLabelPosition(label, position) {
        const vector = position.clone();
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        label.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
    }

    const statusEl = document.getElementById('status');
    function updateStatus() {
        const doZ = objetoReal.position.z;
        const doDist = Math.abs(doZ - vertexZ);
        const invDi = 1 / f - 1 / doDist;
        const di = invDi === 0 ? 999 : 1 / invDi;
        const real = di > 0;
        const magnification = -di / doDist;
        statusEl.innerHTML = `
            Objeto: ${doDist.toFixed(2)} u<br>
            Imagen: ${di.toFixed(2)} u<br>
            Tipo: <b>${real ? 'Real (invertida)' : 'Virtual (derecha)'}</b><br>
            Escala: ${magnification.toFixed(2)}
        `;
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        updateLabelPosition(vertexLabel, vertexMarker.position);
        updateLabelPosition(focoLabel, focoMarker.position);
        rayOjoObjeto.geometry.setFromPoints([ojo.position, objetoReal.position]);
        rayObjetoVertice.geometry.setFromPoints([objetoReal.position, vertexMarker.position]);
        rayObjetoFoco.geometry.setFromPoints([objetoReal.position, focoMarker.position]);
        updateStatus();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
})();
</script>
</body>
</html>
